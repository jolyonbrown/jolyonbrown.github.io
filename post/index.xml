<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on jolyonbrown.com</title>
    <link>https://jolyonbrown.github.io/post/index.xml</link>
    <description>Recent content in Posts on jolyonbrown.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 10 Sep 2014 10:54:24 +0200</lastBuildDate>
    <atom:link href="https://jolyonbrown.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Awk: Set Output Filename Variable via Field Contents</title>
      <link>https://jolyonbrown.github.io/post/awk-set-filename-variable-by-field-contents/</link>
      <pubDate>Wed, 10 Sep 2014 10:54:24 +0200</pubDate>
      
      <guid>https://jolyonbrown.github.io/post/awk-set-filename-variable-by-field-contents/</guid>
      <description>&lt;p&gt;I suspect the title of this post would win a prize for the worst on the internet. Oh well. On a new contract at the moment working with people from various backgrounds in IT. One of my new co-workers had a text file containing a dump of a postgres database and wanted to extract all the CREATE FUNCTION statements out of it for analysis; could I take a look as resident Linux guy? There was a lot of other stuff in the file, the functions were of varying length and split over a number of lines and had a couple of differing closing parameters. Awk was obviously the go-to tool here, but the request had the added complication that each function had to be stored in a seperate output file, named after the function that was being extracted into it. While matching between two patterns is easy in awk, I had some struggle finding out how to dump lines into a file whose name was set by a variable which was in turn set by the contents of a field. Google failed me so I’ve posted this in the hope it helps some other poor soul and saves them the syntax errors I endured figuring it out.&lt;/p&gt;

&lt;p&gt;A CREATE FUNCTION statement looked like this in the file in question:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CREATE FUNCTION function_name(variable name type) RETURNS
another_variable
LANGUAGE plpgsql
AS $$
    DECLARE
    ...
    &amp;lt;Various SQL statements&amp;gt;
    ...
END;
$$;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The $$; sequence was replaced by $_$ in other functions for some reason (personal preference of whoever wrote it I guess). The desired name for the output file would be ‘function_name’ in this example.&lt;/p&gt;

&lt;p&gt;Here’s the (one liner of course) awk statement I ended up using (you may need to scroll to see the whole thing):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;awk -F&#39; |[(]&#39; &#39;/CREATE FUNCTION/ {p=1;name=$3}; p {print &amp;gt; name}; /\$\$;|\$_\$;/ {p=0;close(name)}; &#39; INPUT.sql
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A brief explanation. The parameters to the -F set the awk field delimiter to either (thanks to the | symbol) a space ’ ’ or open bracket &lt;a href=&#34;the square brackets being used to escape the regular one&#34;&gt;(&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The /CREATE FUNCTION/ is the first pattern to match against. When awk sees that, it sets variable p to 1, and sets the variable name to field 3 of that line, which in our case is the name of the function up to the (.&lt;/p&gt;

&lt;p&gt;The p {print &amp;gt; name}; statement prints out lines if p equals 1 (the default action for awk). It also dumps any printed lines into a file, using the name variable as the filename. The position of the ‘p’ in the middle of this statement means that the whole desired range is printed, including the two patterns being matched against.&lt;/p&gt;

&lt;p&gt;The (escaped) $$; sequence is an end pattern to match on, as is the alternative (signified by the | ) $_$; (also escaped). Once either of these is seen, awk sets p to zero, and closes the file. Failing to close the file results in an error relating to too many files being open.&lt;/p&gt;

&lt;p&gt;The INPUT.sql is merely the file awk reads from.&lt;/p&gt;

&lt;p&gt;The result – a long manual edit avoided and many small files, correctly named and containing the correct statements. Good old awk.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>